create extension if not exists postgis;
create schema if not exists geo;

create table if not exists geo.geozone
(
    id          integer generated by default as identity primary key,
    user_id     integer not null,
    title       character varying,
    create_dt   timestamp with time zone default now(),
    update_dt   timestamp with time zone default now(),
    parents     integer[],
    priority    integer,
    region_code smallint
);

comment on column geo.geozone.parents is 'List of geozones id which include (partially or full) this geozone';
comment on column geo.geozone.priority is 'Geozone with higher priority will be check first';

create table geo.gz_polygon
(
    id      integer generated by default as identity primary key,
    gz_id   integer not null references geo.geozone (id),
    polygon geography(polygon)
);

create table geo.gz_circle
(
    id     integer generated by default as identity primary key,
    gz_id  integer not null references geo.geozone (id),
    circle geography(point),
    radius integer check ( radius >= 0 )
);

create table geo.gz_line
(
    id    integer generated by default as identity primary key,
    gz_id integer not null references geo.geozone (id),
    line  geography(linestring),
    width integer check ( width >= 0 )
);


alter table geo.geozone owner to postgres;
alter table geo.gz_circle owner to postgres;
alter table geo.gz_line owner to postgres;
alter table geo.gz_polygon owner to postgres;
create index if not exists gz_polygon_gzid_idx on geo.gz_polygon using btree(gz_id);
create index if not exists gz_line_gzid_idx on geo.gz_line using btree(gz_id);
create index if not exists gz_circle_gzid_idx on geo.gz_circle using btree(gz_id);
create index if not exists geozone_uid_idx on geo.geozone using btree(user_id);
grant select on geo.geozone, geo.gz_circle, geo.gz_line, geo.gz_polygon to receiver, worker, lbs_decoder;


create or replace function geo.tg_geometry_notify ()
    returns trigger
    language plpgsql
as $$
declare
    channel text := TG_ARGV[0];
begin
    PERFORM (
        with payload(id, tablename, op) as
                 (
                     select
                         (case when NEW is NULL THEN OLD.id ELSE NEW.id END) as id,
                         TG_TABLE_NAME,
                         TG_OP
                 )
        select pg_notify(channel, payload::text)
        from payload
    );
    RETURN NULL;
end;
$$;


CREATE TRIGGER geometry_modify
    AFTER INSERT OR UPDATE OR DELETE
    ON geo.gz_polygon
    FOR EACH ROW
EXECUTE PROCEDURE geo.tg_geometry_notify('geometry_modify');

CREATE TRIGGER geometry_modify
    AFTER INSERT OR UPDATE OR DELETE
    ON geo.gz_line
    FOR EACH ROW
EXECUTE PROCEDURE geo.tg_geometry_notify('geometry_modify');

CREATE TRIGGER geometry_modify
    AFTER INSERT OR UPDATE OR DELETE
    ON geo.gz_circle
    FOR EACH ROW
EXECUTE PROCEDURE geo.tg_geometry_notify('geometry_modify');


-- service function to convert `geo` field into geography
create or replace function fn_geography_from_point(pos point)
    returns geography(point)
as
$$
declare
begin
    return st_setsrid(st_point(pos[1], pos[0])::geography, 4326);
end
$$ language 'plpgsql';


create or replace function fn_geography_from_json(pos jsonb)
returns geography(point)
as $$
declare
begin
    return st_setsrid(st_point((pos->>'lon')::float, (pos->>'lat')::float)::geography, 4326);
end
$$ language 'plpgsql';
--
-- -- calculate minimal distance between geozone with id @geozone_id and position @last_pos
-- create or replace function get_min_dist(last_pos geography, geozone_id integer) returns integer
--     language plpgsql
-- as
-- $$
-- declare
--         result integer := 0;
--         cur_min integer := 0;
--     begin
--     -- st_transform need to get distance in meter
--         select min(st_distance(st_transform(last_pos::geometry, 3857), st_transform(polygon::geometry, 3857)))
--         into result from geo.gz_polygon
--             where gz_polygon.gz_id = geozone_id;
-- --             select min(st_distance(last_pos, polygon))
-- --                     into result from geo.gz_polygon
-- --              where gz_polygon.gz_id = geozone_id;
--         if result = 0 then
--             return 0;
--         end if;
--         select min(st_distance(last_pos, circle) - radius) into cur_min from geo.gz_circle
--             where gz_circle.gz_id = geozone_id;
--         if cur_min <= 0 then
--             return 0;
--         end if;
--         if cur_min < result then
--             result := cur_min;
--         end if;
--         select min(st_distance(last_pos, line) - width) into cur_min from geo.gz_line
--             where gz_line.gz_id = geozone_id;
--         if cur_min < result or cur_min <= 0 then
--             return cur_min;
--         else
--             return result;
--         end if;
--     end;
-- $$;
--
-- -- check that @last_pos is inside geozone with id @geozone_id
-- create or replace function is_inside(last_pos geography, acr integer, geozone_id integer)
-- returns boolean
-- as $$
--     declare
--         min_dist integer := get_min_dist(last_pos, geozone_id);
--     begin
--         if acr is not null then
--             if min_dist <= acr then
--                 return true;
--             end if;
--         elseif min_dist = 0 then
--             return true;
--         end if;
--         return false;
--     end
-- $$ language 'plpgsql';
--
-- create or replace function is_inside_array(geo_point geography, acr integer, geozones_id integer[])
-- returns bigint[]
-- as $$
--     declare
--         result integer [];
--         el integer;
--     begin
--         FOREACH el IN ARRAY geozones_id
--         LOOP
--      IF is_inside(geo_point, acr, el) THEN
--              result := array_append(result, el);
--            END IF;
--         END LOOP;
--         return result;
--     end
-- $$ language 'plpgsql';
--
-- -- return list of devices which location is inside any of geozones
-- create or replace function fn_get_devices_inside(dhs bigint[], geozones integer[])
--     returns bigint[] language plpgsql
-- as $$
-- declare
--     result bigint[];
-- begin
--     with c as
--              (select polygon, circle, radius, line, width
--               from geo.gz_circle
--                        full outer join geo.gz_polygon on gz_circle.gz_id = gz_polygon.gz_id
--                        full outer join geo.gz_line on gz_circle.gz_id = gz_line.gz_id
--               where gz_polygon.gz_id = any(geozones))
--     select array_agg(device_hash) into result from data_processed, c
--            where device_hash = any(dhs)
--              and (st_dwithin(location, polygon, coalesce(acr, 0)) is true
--                  or st_dwithin(location, line, coalesce(acr+width, 0)) is true
--                  or st_dwithin(location, circle, coalesce(acr+radius, 0)) is true);
--     return result;
-- end;
-- $$;
--
--
-- create or replace function fn_get_current_geozones(dhs bigint[], geozones integer[])
--     returns jsonb language plpgsql
-- as $$
-- declare
--     result jsonb := jsonb_build_object();
--     path text[];
--     i record;
-- begin
--     for i in
--     with c as
--              (select polygon, circle, radius, line, width, coalesce(gz_line.gz_id, gz_circle.gz_id, gz_polygon.gz_id) as gz_id
--               from geo.gz_circle
--                        full outer join geo.gz_polygon on gz_circle.gz_id = gz_polygon.gz_id
--                        full outer join geo.gz_line on gz_circle.gz_id = gz_line.gz_id
--               where gz_polygon.gz_id = any(geozones))
--     select device_hash, gz_id from data_processed, c
--         where device_hash = any(dhs)
--         and (st_dwithin(location, polygon, coalesce(acr, 0)) is true
--             or st_dwithin(location, line, coalesce(acr+width, 0)) is true
--             or st_dwithin(location, circle, coalesce(acr+radius, 0)) is true) loop
--         path = '{' || i.device_hash::text || '}';
--         result = jsonb_set(result, path,
--             coalesce(result->(i.device_hash::text), '[]'::jsonb) || jsonb_build_array(i.gz_id), true);
--         end loop;
--     return result;
-- end;
-- $$;
