create extension if not exists postgis;
set statement_timeout = 0;
set lock_timeout = 0;
set client_encoding = 'utf8';
set standard_conforming_strings = on;
set check_function_bodies = false;
set client_min_messages = warning;
set row_security = off;
set search_path = public, pg_catalog;
set default_tablespace = '';
set default_with_oids = false;


create table xkdb_databases
(
    id integer generated by default as identity primary key,
    host text not null,
    port integer not null,
    protocol text not null,
    user_name text,
    password text,
    options text,
    cluster_id integer
);
alter table xkdb_databases owner to postgres;
grant select, update on table xkdb_databases to worker;
grant select on table xkdb_databases to lbs_decoder;
insert into xkdb_databases(id,host,port,protocol,user_name,password,cluster_id)
values (0,'xkdb',11001,'xkdb','worker','123456', 0);

create table if not exists devices
(
    id              integer generated by default as identity primary key,
    device_hash     bigint,
    sim_1           numeric(19, 0),
    sim_2           numeric(19, 0),
    gsm_imei        numeric(19, 0),
    wimei           numeric(19, 0),
    password        character varying(16),
    brand_id        smallint,
    model_id        smallint,
    software        character varying(5),
    localization_id smallint,
    partner_id      smallint,
    edition         character varying(80),
    email_send_mode boolean                  default false,
    email_send      boolean                  default false,
    extra           jsonb                    default '{}'::jsonb,
    create_dt       timestamp with time zone default now(),
    update_dt       timestamp with time zone default now(),
    time_zone_id    integer,
    server_id       integer not null references xkdb_databases(id),
    device_to       integer,
    name            character varying(64),
    unique(device_hash)
);

alter table devices owner to postgres;
create index if not exists devices_sims_imei_pkey on devices using btree (sim_1, sim_2, gsm_imei, wimei);
create index if not exists device_partner_idx on devices using btree(partner_id);

grant select, insert, update on table devices to worker;



create table scanner_device
(
    sim_1       bigint,
    "group"     text,
    type        text,
    imei        bigint,
    part_number text,
    cladr       bigint,
    region      text,
    account     text,
    id          bigint not null
        constraint scanner_device_pk
            primary key
);
alter table scanner_device
    owner to postgres;
grant select on scanner_device to worker;
grant select on scanner_device to lbs_decoder;

create table carcade_device
(
    sim_1 bigint not null
        constraint carcade_device_pk
            primary key
);
alter table carcade_device
    owner to dbakhtiyarov;

create or replace function fn_update_searchsys() returns trigger
    language plpgsql
as $$
declare
sim1 bigint;
begin
    if coalesce(new.brand_id, 1) = 1 then
        return new;
end if;
    if new.sim_1 is not null and new.password is not null then
        return new;
end if;

    if new.sim_1 is null then
select sim_1 into sim1 from scanner_device where imei = new.gsm_imei;
new.sim_1 := sim1;
end if;
    if new.password is null then
        new.password := '0011';
end if;
return new;

end;$$;
create trigger trg_upd_searchsys before insert or update on devices for each row execute procedure fn_update_searchsys();

create table if not exists status
(
    id              bigint generated by default as identity primary key,
    device_hash     bigint                   not null references devices (device_hash),
    first_dt        timestamp with time zone,
    device_dt       timestamp with time zone not null,
    location        geography(point),
    location_type   smallint,
    location_dt     timestamp with time zone,
    extra           jsonb                    default '{}'::jsonb,
    extra_dt        jsonb                    default '{}'::jsonb,
    geozones        integer[],
    geozones_source smallint,
    geozones_dt     timestamp with time zone,
    address         jsonb,
    address_dt      timestamp with time zone,
    is_deleted      boolean                  default false,
    update_dt       timestamp with time zone default now(),
    recv_dt         timestamp with time zone default now(),
    access_dt       timestamp with time zone default '2000-01-01 00:00:00+00'::timestamp with time zone,
    unique (device_hash),
    CHECK (geozones IS NULL AND geozones_source IS NULL OR geozones IS NOT NULL AND geozones_source IS NOT NULL),
    CHECK ( (address IS NULL AND address_dt IS NULL) OR (address IS NOT NULL AND address_dt IS NOT NULL) ),
    CHECK ( (location is null and location_dt is null and location_type is null) or
            (location is not null and location_dt is not null and location_type is not null) )
);
alter table status owner to postgres;
grant select, insert, update on status to worker;
grant select on status to retranslator, mail_sender;
grant select, update(access_dt) on status to history_api;
grant select, update on status to lbs_decoder;
grant select,update(address,address_dt,update_dt) on status to geocoding;
comment on column status.geozones_source is 'AWAIT = -1, GPS = 0, GSM = 1, WIFI = 2 ';
comment on column status.location_type is 'AWAIT = -1, GPS = 0, GSM = 1, WIFI = 2 ';


create table if not exists data_processed
(
    id          bigint generated by default as identity primary key,
    device_hash bigint not null references devices(device_hash),
    device_dt   timestamp with time zone not null,
    update_dt   timestamp with time zone default now(),
    extra       jsonb                    default '{}'::jsonb,
    geo         point,
    extra_dt    jsonb                    default '{}'::jsonb,
    geo_dt      timestamp with time zone,
    first_dt    timestamp with time zone,
    recv_dt     timestamp with time zone default now(),
    access_dt   timestamp with time zone default '2000-01-01 00:00:00+00'::timestamp with time zone,
    is_deleted  boolean default false,
    location    geography(point),
    acr         integer,
    geozones    integer[],
    geozones_source smallint,
    geozones_dt timestamp with time zone,
    location_type smallint,
    location_dt timestamp with time zone,
    address jsonb,
    address_dt timestamp with time zone,
    unique(device_hash),
    constraint data_processed_geozones_check
    CHECK (geozones IS NULL AND geozones_source IS NULL OR geozones IS NOT NULL AND geozones_source IS NOT NULL),
    constraint data_processed_location_check
    CHECK ( (location is null and location_dt is null and location_type is null) or
            (location is not null and location_dt is not null and location_type is not null) ),
    constraint data_processed_location_srid_check
    check ( st_srid(location) = 4326 )
);
alter table data_processed owner to postgres;
grant select, insert, update on data_processed to worker;
grant select on data_processed to retranslator, mail_sender;
grant select, update(access_dt) on data_processed to history_api;
grant select, update on data_processed to lbs_decoder;
grant select,update(address,address_dt,update_dt) on data_processed to geocoding;
comment on column data_processed.geozones_source is 'GPS = 0, GSM = 1, WIFI = 2 ';
comment on column data_processed.location_type is 'GPS = 0, GSM = 1, WIFI = 2 ';

grant select(device_hash, device_dt, location, location_type, location_dt, address, address_dt) on data_processed to sls_tg_bot;
grant select(device_hash, sim_1, sim_2) on devices to sls_tg_bot;

create or replace function fn_is_gps_valid(gps point) returns bool
as
$$
begin
    return gps is not null;
end;
$$ language 'plpgsql';


create or replace function fn_is_point_valid(gsm jsonb) returns bool
as
$$
begin
    if(gsm is not null) then
        if(gsm ? 'lat' and gsm ? 'lon') then
            if(gsm->>'lat' is not null and gsm->>'lon' is not null) then
                return true;
            else
                return false;
            end if;
        else
            return false;
        end if;
    else
        return false;
    end if;
end;
$$ language 'plpgsql';


create or replace function fn_update_location() returns trigger
    language plpgsql
as $$
declare
    gps_dt timestamp with time zone;
    gsm_dt timestamp with time zone;
    wifi_dt timestamp with time zone;
    location_dt timestamp with time zone;
begin
    if new.geo is null and new.extra->'gsm_dec' is null and new.extra->'wifi_dec' is null then
        return new;
    end if;

    gps_dt := case
        when fn_is_gps_valid(new.geo) and new.geo_dt is not null
            then new.geo_dt
        else
            null
        end;
    gsm_dt := case
        when fn_is_point_valid(new.extra->'gsm_dec') and new.extra_dt ? 'gsm_dec'
            then (new.extra_dt->>'gsm_dec')::timestamp at time zone 'utc'
        else
            null
        end;
    wifi_dt := case
        when fn_is_point_valid(new.extra->'wifi_dec') and new.extra_dt ? 'wifi_dec'
            then (new.extra_dt->>'wifi_dec')::timestamp at time zone 'utc'
        else
            null
        end;
    location_dt = coalesce(new.location_dt, '2000-01-01 00:00:00+00')::timestamp with time zone;
    if(gps_dt is not null and gps_dt >= location_dt) then
        new.location := fn_geography_from_point(new.geo);
        new.location_dt := gps_dt;
        new.location_type := 0;
        new.acr := 0;
    end if;
    if(gsm_dt is not null and gsm_dt > location_dt) then
        new.location := fn_geography_from_json(new.extra->'gsm_dec');
        new.location_dt := gsm_dt;
        new.location_type := 1;
        if(new.extra->'gsm_dec' ? 'acr' and new.extra->'gsm_dec'->>'acr' is not null) then
            new.acr := (new.extra->'gsm_dec'->'acr')::integer;
        else
            new.acr = null;
        end if;
    end if;
    if(wifi_dt is not null and wifi_dt > location_dt)then
        new.location := fn_geography_from_json(new.extra->'wifi_dec');
        new.location_dt := wifi_dt;
        new.location_type := 2;
        if(new.extra->'wifi_dec' ? 'acr' and new.extra->'wifi_dec'->>'acr' is not null) then
            new.acr := (new.extra->'wifi_dec'->'acr')::integer;
        else
            new.acr = null;
        end if;
    end if;
    new.extra = new.extra - 'location' - 'location_type' - 'location_cache';
    new.extra_dt = new.extra_dt - 'location';
    return new;
end;$$;
create trigger trg_upd_location before insert or update on data_processed for each row execute procedure fn_update_location();


create table if not exists user_settings
(
    id          integer generated by default as identity primary key,
    device_hash bigint                                not null references devices (device_hash),
    create_dt   timestamp with time zone default now(),
    update_dt   timestamp with time zone default now(),
    active      boolean                  default true not null,
    name        character varying(64),
    geozones    integer[]
);

alter table user_settings owner to postgres;
create index if not exists user_settings_dh_idx on user_settings using btree (device_hash);

grant select on user_settings to worker;
grant select on user_settings to mail_sender;


create table commands_databases
(
    id          bigint generated by default as identity primary key,
    host        text not null,
    port        integer not null,
    user_name   text,
    password    text,
    database    text
);
alter table commands_databases owner to postgres;
grant select on commands_databases to history_api;

create table server_settings
(
    name text not null,
    value_bigint bigint,
    value_string text,
    constraint server_settings_pkey primary key (name)
);
grant select on table server_settings to receiver, worker, lbs_decoder, history_api, retranslator, mail_sender;
insert into server_settings(name, value_bigint) (values('kafka.queue.buffering.max.messages', 1000000), ('kafka.enabled', 1));
insert into server_settings(name, value_string) (values('kafka.metadata.broker.list', '127.0.0.1:9092'), ('worker.kafka.topic', 'scripted_devices'));


create table if not exists commands
(
    id          bigint generated by default as identity primary key,
    device_hash bigint not null references devices(device_hash),
    extra       jsonb                    default '{}'::jsonb,
    create_dt   timestamp with time zone default now(),
    update_dt   timestamp with time zone default now(),
    last_send_dt jsonb default '{}'::jsonb,
    unique(device_hash)
);
alter table commands owner to postgres;
grant select,update on table commands to receiver;

-- because values in range [0-10] are a special values
CREATE SEQUENCE IF NOT EXISTS settings_profile_id_seq
    AS integer
    START WITH 11
    INCREMENT BY 1
    MINVALUE 1
    MAXVALUE 255
    CACHE 1
    CYCLE;
create table if not exists settings_profile
(
    id integer DEFAULT nextval('settings_profile_id_seq'::regclass) primary key
        CONSTRAINT profile_id_valid CHECK ( id >= 0 AND id <= 255 ),
    name varchar,
    counterparty_id integer,
    created_id integer,
    updated_id integer,
    settings jsonb,
    created_at timestamp with time zone,
    updated_at timestamp with time zone
);
alter table settings_profile owner to postgres;
grant select on table settings_profile to receiver;

comment on column settings_profile.id is '0 = partner device await settings_profile from server; 1 - retail device profile; [2-10] - reserved values; [11-255] - profile of counterpart';
insert into settings_profile(id, name, created_at, updated_at, settings) values(0, 'Сброс профиля', now(), now(), '{}');

create table if not exists device_profile
(
    id integer generated by default as identity primary key,
    profile_id integer not null references settings_profile(id),
    device_hash bigint not null references devices(device_hash) unique,
    created_id integer,
    created_at timestamp with time zone,
    updated_at timestamp with time zone
);
alter table device_profile owner to postgres;
grant select on table device_profile to receiver;
create index if not exists device_profile_idx on device_profile using btree(device_hash);


create table if not exists settings_profile_log
(
    id integer generated by default as identity primary key,
    profile_id integer not null references settings_profile(id),
    user_id integer,
    comment varchar,
    settings_before jsonb,
    settings_after jsonb,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    action integer
);


create table history_api_log (
    device_hash bigint not null,
    create_dt timestamp with time zone default now(),
    extra jsonb
);
alter table history_api_log owner to postgres;
grant all on history_api_log to history_api;



CREATE OR REPLACE FUNCTION notify_data_processed_changes() RETURNS trigger
    LANGUAGE plpgsql
    AS $$declare

  id             bigint := NEW.id;
  device_hash    text := NEW.device_hash::text;
  device_dt      timestamp with time zone := NEW.device_dt;
  update_dt      timestamp with time zone := NEW.update_dt;
  extra          jsonb                       := NEW.extra;
  geo            point                       := NEW.geo;
  extra_dt       jsonb                       := NEW.extra_dt;
  geo_dt         timestamp with time zone := NEW.geo_dt;
  first_dt       timestamp with time zone := NEW.first_dt;

  message         text := '{';

begin
  message := message ||
    '"id": ' || id ||
    ', "device_hash": ' || device_hash ||
    ', "device_dt": ' || quote_literal(to_char(device_dt, 'YYYY-MM-DD HH24:MI:SS')) ||
    ', "update_dt": ' || quote_literal(to_char(update_dt, 'YYYY-MM-DD HH24:MI:SS')) ||
    ', "extra": ' || (extra#>>'{}') ||
    ', "geo": ' || quote_nullable(geo) ||
    ', "extra_dt": ' || (extra_dt#>>'{}') ||
    ', "geo_dt": ' || quote_nullable(quote_literal(to_char(geo_dt, 'YYYY-MM-DD HH24:MI:SS'))) ||
    ', "first_dt": ' || quote_literal(to_char(first_dt, 'YYYY-MM-DD HH24:MI:SS')) ||
    '}';


--  RAISE NOTICE 'Device_hash: %', message;
  PERFORM pg_notify(device_hash, message);
  return NEW;

end
$$;


create or replace function fn_version(brand_id        smallint,
                                      model_id        smallint,
                                      software        character varying(5),
                                      localization_id smallint,
                                      partner_id      smallint,
                                      edition         character varying(80)) returns character varying(32)
    language plpgsql
as $$
    begin
        return coalesce(brand_id::text, 'null') || '.' || coalesce(model_id::text, 'null') || '.'
                   || coalesce(software, 'null') || '.' || coalesce(localization_id::text, 'null')
                   || '.' || coalesce(partner_id::text, 'null') || '.' || coalesce(edition, 'null');
    end;
$$;
-- ALTER FUNCTION public.notify_data_processed_changes() OWNER TO "postgres";